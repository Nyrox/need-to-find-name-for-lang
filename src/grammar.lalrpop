use repr;
use repr::untyped;
use repr::typed;

grammar;

pub Ast: untyped::Ast = {
    <TopLevelDecl+> => untyped::Ast { declarations: <> }
};

TopLevelDecl: untyped::TopLevelDeclaration = {
    FuncDecl
}

FuncDecl: untyped::TopLevelDeclaration = {
    "fn" <i: Ident> "(" ")" "->" <t: Type> <b: Block> => untyped::TopLevelDeclaration::FunctionDeclaration(i, b, t)
}

Block: Vec<untyped::Statement> = {
    "{" <s: Statement*> "}" => s
}

Statement: untyped::Statement = {
    VariableAssignment,
    VariableDeclaration,
    <e: Expr> ";" => untyped::Statement::ExpressionStatement(e),
    "return" <e: Expr> ";" => untyped::Statement::ReturnStatement(e),
}

VariableAssignment: untyped::Statement = {
    <l: Ident> "=" <e: Expr> ";" => untyped::Statement::VariableAssignment(l, e)
}

VariableDeclaration: untyped::Statement = {
    "let" <l: Ident> ":" <t: Type> ";" => untyped::Statement::VariableDeclaration(l, t)
};

Expr: untyped::Expression = {
    <l: Expr> "+" <r: Factor> => untyped::Expression::BinaryOperation(Box::new(l), repr::BinaryOperation::Add, Box::new(r)),
    <l: Expr> "-" <r: Factor> => untyped::Expression::BinaryOperation(Box::new(l), repr::BinaryOperation::Sub, Box::new(r)),
    Factor,
};

Factor: untyped::Expression = {
    <l: Factor> "as" <r: Type> => untyped::Expression::Cast(Box::new(l), r),
    <l: Factor> "*" <r: Term> => untyped::Expression::BinaryOperation(Box::new(l), repr::BinaryOperation::Mul, Box::new(r)),
    <l: Factor> "/" <r: Term> => untyped::Expression::BinaryOperation(Box::new(l), repr::BinaryOperation::Div, Box::new(r)),
    Term,
};

Term: untyped::Expression = {
    ConstantValue => untyped::Expression::Constant(<>),
    Ident => untyped::Expression::VariableLookup(<>),
    <Ident> "(" ")" => untyped::Expression::FunctionCall(<>),
    "(" <Expr> ")",
};

// Fix matching ambiguity for integers and decimals
match {
	r"[0-9]+" => _integer,
} else {
	r"[0-9]+.[0-9]+" => _decimal,
	_
}	

Ident: String = r"\w[\w\d]*" => <>.to_owned();

Type: repr::Type = {
    "i32" => repr::Type::INTEGER_32,
    "f32" => repr::Type::FLOAT_32,
}

ConstantValue: repr::Value = {
    _integer => repr::Value::Integer(<>.parse().unwrap()),
    _decimal => repr::Value::Decimal(<>.parse().unwrap()),
};